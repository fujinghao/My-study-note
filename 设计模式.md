## 单例模式
单例模式是一种设计模式，确保一个类只有一个实例，并提供一个全局访问点。它的主要用途包括：
- 控制实例数量：确保一个类只有一个实例，避免创建多个实例导致的资源浪费或不一致。
- 全局访问点：提供一个全局访问点，方便在整个应用程序中访问该实例。
- 延迟实例化：在需要时才创建实例，避免程序启动时就占用资源。


可以在编写程序时手动保证一个类只有一个实例，但这可能会带来一些问题：
- 代码复杂性：手动管理实例的创建和销毁会增加代码的复杂性，容易出错。
- 全局访问：单例模式提供了一个全局访问点，手动管理实例时需要额外的代码来实现这一点。
- 线程安全：多线程环境下，手动管理实例的创建和销毁可能会导致线程安全问题。

懒汉模式：在需要时才创建实例，避免程序启动时就占用资源。
**经典双检锁懒汉模式**：在多线程环境下，确保只有一个线程创建实例。
```cpp
class single{
private:
    static single* instance;
    static mutex lock;
    single(){}
    ~single(){}
public:
    static single* getinstance(){
        if(instance == nullptr){
            lock.lock();//std::lock_guard<std::mutex> guard(lock);
            if(instance == nullptr){
                instance = new single();
            }
            lock.unlock();//使用lock_guard时自动释放锁.
        }
        return instance;
    }
}
single* single::instance = nullptr;
std::mutex single::lock;
int main() {
    single* s1 = single::getInstance();
    single* s2 = single::getInstance();

    std::cout << "Instance 1 address: " << s1 << std::endl;
    std::cout << "Instance 2 address: " << s2 << std::endl;

    return 0;
}
```
**局部静态变量实现懒汉模式**：C++11规定，在一个线程开始local static 对象的初始化后到完成初始化前，其他线程执行到这个local static对象的初始化语句就会等待，直到该local static 对象初始化完成。

```cpp
class single{
private:
    single(){}
    ~single(){}
public:
    static single* getinstance() {
        static single instance;
        return &instance;
    }
}
```

饿汉模式：在程序启动时就创建实例，确保实例的唯一性。
```cpp
class single{
private:
    static single* instance;
    single(){}
    ~single(){}
public:
    static single* getinstance(){
        return instance;
    }
}   
single* single::instance = new single();//静态成员变量的初始化
``` 

