## 1.  什么是回调函数？

回调函数可以被简单地理解为：A函数作为参数传递给B函数，然后B函数在执行的某一时刻调用A函数。这里的A函数就是回调函数。

回调处理网络请求示例:

```cpp
#include <iostream>
#include <thread>
#include <functional>
#include <chrono>
 
// 模拟网络请求函数，接受一个回调函数
void asyncNetworkRequest(std::function<void(const std::string&)> callback) {
    std::this_thread::sleep_for(std::chrono::seconds(2)); // 模拟网络延迟
    std::string response = "Server response data";
    callback(response); // 调用回调函数并传递响应数据
}
 
// 回调函数
void onRequestCompleted(const std::string& response) {
    std::cout << "Network request completed with response: " << response << std::endl;
}
 
int main() {
    std::cout << "Sending network request..." << std::endl;
    
    // 异步发送网络请求，并传递回调函数
    std::thread requestThread(asyncNetworkRequest, onRequestCompleted);
    
    std::cout << "Doing other work while waiting for network response..." << std::endl;
    
    // 主线程可以继续做其他工作
    std::this_thread::sleep_for(std::chrono::seconds(1));
    std::cout << "Still doing other work..." << std::endl;
    
    // 等待网络请求完成
    requestThread.join(); // 等待线程完成
    
    return 0;
}
```



## 2.  C++的多态？

**多态的概念:**通俗来讲，多态就是多种形态，具体来讲，就是去完成某个行为，当不同的对象去完成时会产生不同的状态。当基类指针指向子类对象时候，虚函数能实现运行时多态（多态指：同一个接口的不同实现方式）

**多态的分类:** 多态可以分为**编译时的多态**和**运行时的多态**。前者主要是指 **函数的重载**（包括运算符的重载）、对重载函数的调用，在编译时就能根据实参确定应该调用哪个函数，因此叫编译时的多态；而后者则和继承、虚函数等概念有关。

**多态的构成条件:**
1. 必须通过基类的指针或者引用调用虚函数。
2. 被调用的函数必须是虚函数，且派生类必须对基类的虚函数进行重写。
3. 必须存在继承关系

## 3.  C++之函数重载和函数重写
**函数重载：** 重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。（在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。不能仅通过返回类型的不同来重载函数。）
**函数重载好处：** 函数重载通常用来命名一组功能相似的函数，这样做减少了函数名的数量，避免了名字空间的污染，对于程序的可读性有很大的好处。
**函数重载特征是：**
 （1）相同的范围（在同一个作用域中）；
 （2）函数名字相同；
 （3）参数不同；
 （4）返回值可以不同；

**函数重写（也称为覆盖 override）：** 函数重写是指子类重新定义基类的虚函数。

**特征是：**
 （1）不在同一个作用域（分别位于派生类与基类）；
 （2）函数名字相同；
 （3）参数相同；
 （4）基类函数必须有 virtual 关键字，不能有 static 。
 （5）返回值相同，否则报错；
 （6）重写函数的访问修饰符可以不同；

## 4.  虚函数

**虚函数：** 即被virtual修饰的类成员函数称为虚函数。
一旦定义了虚函数，该基类的派生类中同名函数也自动成为了虚函数。也就是说在派生类中有一个和基类同名的函数，只要基类加了virtual修饰，派生类不加virtual修饰也是虚函数。
这里有几点需要注意：

- **静态成员函数不能是虚函数**。这是因为静态成员函数并不依赖于对象实例，它们没有 "this" 指针，但是虚函数在实现多态时通过 "this" 指针访问虚表来找到正确的函数版本。因此，静态成员函数不能被声明为虚函数。

- **普通函数（也就是非成员函数）也不能是虚函数**。因为普通函数（全局函数或静态函数）不属于任何类，自然就没有继承的概念，因此也就不可能有虚函数。

- **构造函数不能声明为虚函数**。虚函数是通过虚函数表来实现的，每个对象都有一个虚函数表指针，指向该类的虚函数表。而**对象在构造函数中才初始化虚函数表指针**，如果构造函数是虚函数，就需要通过虚函数表来调用，但此时对象还没有实例化，也就没有虚函数表指针，无法找到虚函数表，因此构造函数不能是虚函数。



**虚函数的重写( 覆盖 )：** 派生类中有一个跟基类完全相同的虚函数(即派生类虚函数与基类虚函数的返回值类型、函数名字、参数列表完全相同)，称子类的虚函数重写了基类的虚函数。  

**虚析构函数：** 虚析构函数的作用是为了**避免内存泄露**，而且是当子类中会有指针 成员变量 时才会使用得到的。也就说虚析构函数使得在删除**指向子类对象的基类指针**时可以调用子类的析构函数达到释放子类中堆内存的目的，而防止内存泄露的。

当父类的析构函数不声明成虚析构函数的时候，当子类继承父类，父类的指针指向子类时，delete掉父类的指针，只调动父类的析构函数，而不调动子类的析构函数。

当父类的析构函数声明成虚析构函数的时候，当子类继承父类，父类的指针指向子类时，delete掉父类的指针，先调动子类的析构函数，再调动父类的析构函数。

**纯虚函数：** 基类中不对虚函数给出有意义的实现，它只是在派生类中有具体的意义。这时基类中的虚函数只是一个入口，具体的目的地由不同的派生类中的对象决定。这个虚函数称为纯虚函数。

1、在定义纯虚函数时，不能定义虚函数的实现部分。
2、把函数名赋值为0，本质上是将指向函数体的指针值赋为初值0。与定义空函数不一样，空函数的函数体为空，即调用该函数时，不执行任何动作。没有在派生类重新定义这种虚函数之前，是不能调用这种纯虚函数的。
3、把至少包含一个纯虚函数的类，称为**抽象类**。这种类**只能作为派生类的基类**，不能用来创建对象。
其理由是明显的：纯虚函数在类的vftable表中对应的表项被赋值为0。也就是指向一个不存在的函数。由于编译器绝对不允许有调用一个不存在的函数的可能，所以该类不能生成对象。在它的派生类中，除非重写此函数，否则也不能生成对象。
4、在以抽象类作为基类的派生类中必须有纯虚函数的实现部分，即必须有重写纯虚函数的函数体。否则，这样的派生类也是不能产生对象的。 综上所述，可把纯虚函数归结为：**抽象类的唯一用途是为派生类提供基类，纯虚函数的作用是作为派生类中的成员函数的基础，并实现动态多态性**。

**抽象类：**C++接口时通过抽象类实现的,设计抽象类的目的,是为了给其他类提供一个可以继承的适当的基类.抽象类本类不能被用于实例化对象,只能作为接口使用。在C++中,我们把**只能用于被继承而不能直接创建对象的类**称之为**抽象类**,这种基类不能直接生成对象,而只有被继承后,并重写其虚函数后,才能使用。当抽象类的派生类实现了继承而来的纯虚函数后,才能实例化对象。

```cpp
class VirtualClass{
	public:
		virtual void fun1() = 0;//纯虚函数

		virtual ~VirtualClass();
};



class ClassA : public VirtualClass{
	public:
		void fun1(){
			printf("The is ClassA fun1\n");
		};

		virtual ~ClassA();
		
};


VirtualClass:: ~VirtualClass(){
}

ClassA:: ~ClassA(){
}

int main(){
	//编译报错，这个非法的。抽象类是不可以被实例化的，必须被继承，才能够被实例化
	VirtualClass * virtualClass = new VirtualClass();//error: cannot allocate an object of abstract type 'VirtualClass'
	
	VirtualClass * classA = new ClassA();
	classA->fun1();
	return 0;
}

```



## 4.  虚函数表

**什么是虚函数表：**

- 虚函数表是一个指针数组，其元素是虚函数的指针，每个元素对应一个虚函数的函数指针。每一个有虚函数的类（或者从有虚函数的类继承而来的类）都有一个相关联的虚函数表。需要指出的是，普通的函数即非虚函数，其调用并不需要经过虚表，所以虚表的元素并不包括普通函数的函数指针。
- 每个有虚函数的对象都包含一个指向其类的虚函数表的指针。这个指针通常被称为 vptr。
-   当调用一个对象的虚函数时，编译器使用对象的 vptr 来定位类的虚函数表。接着，从虚函数表中找到相应的虚函数指针并调用该函数。这个过程是在运行时进行的，因此可以实现多态行为。
- 虚表内的条目，即虚函数指针的赋值发生在编译器的编译阶段，也就是说在代码的编译阶段，虚表就可以构造出来了。
- 当一个类继承自另一个有虚函数的类，并且没有重写任何虚函数，该类的对象将使用父类的虚函数表。
- 当派生类重写了基类的虚函数，派生类的虚函数表中该函数的入口会被更新为指向派生类版本的函数。
- 如果派生类添加了新的虚函数，它们会被添加到虚函数表的末尾。
- 虚函数表是编译器生成的，程序运行时被载入内存。一个类的虚函数表中列出了该类的全部虚函数地址。

```cpp
#include <iostream>
using namespace std;
class A
{
public:
    int i;
    virtual void func() {}
    virtual void func2() {}
};
class B : public A
{
    int j;
    void func() {}
};
int main()
{
    cout << sizeof(A) << ", " << sizeof(B);  //输出 8,12
    return 0;
}
```

在 32 位编译模式下，程序的运行结果是：
8, 12

如果将程序中的 virtual 关键字去掉，输出结果变为：
4, 8

对比发现，有了虚函数以后，对象所占用的存储空间比没有虚函数时多了 4 个字节。实际上，任何有虚函数的类及其派生类的对象都包含这多出来的 4 个字节，这 4 个字节就是实现多态的关键——它位于对象存储空间的最前端，其中存放的是虚函数表的地址。

每一个有虚函数的类（或有虚函数的类的派生类）都有一个虚函数表，该类的任何对象中都放着该虚函数表的指针（可以认为这是由编译器自动添加到构造函数中的指令完成的）。

虚函数表是编译器生成的，程序运行时被载入内存。一个类的虚函数表中列出了该类的全部虚函数地址。例如，在上面的程序中，类 A 对象的存储空间以及虚函数表（假定类 A 还有其他虚函数）如图所示:

<div align=center><img src=".\fig\虚函数表1.webp"height="565"/> </div>

类 B 对象的存储空间以及虚函数表（假定类 B 还有其他虚函数）如图所示：

<div align=center><img src=".\fig\虚函数表2.webp"height="565"/> </div>

假设 pa 的类型是 A*，则 pa->func() 这条语句的执行过程如下：

1. 取出 pa 指针所指位置的前 4 个字节，即对象所属的类的虚函数表的地址（在 64 位编译模式下，由于指针占 8 个字节，所以要取出 8 个字节）。如果 pa 指向的是类 A 的对象，则这个地址就是类 A 的虚函数表的地址；如果 pa 指向的是类 B 的对象，则这个地址就是类 B 的虚函数表的地址。

2. 根据虚函数表的地址找到虚函数表，在其中查找要调用的虚函数的地址。不妨认为虚函数表是以函数名作为索引来查找的，虽然还有更高效的查找方法。如果 pa 指向的是类 A 的对象，自然就会在类 A 的虚函数表中查出 A::func 的地址；如果 pa 指向的是类 B 的对象，就会在类 B 的虚函数表中查出 B::func 的地址。类 B 没有自己的 func2 函数，因此在类 B 的虚函数表中保存的是 A::func2 的地址，这样，即便 pa 指向类 B 的对象，`pa->func2();`这条语句在执行过程中也能在类 B 的虚函数表中找到 A::func2 的地址。

3. 根据找到的虚函数的地址调用虚函数。

## 5.  智能指针

C++11 中引入了智能指针（Smart Pointer），它利用了一种叫做 RAII（资源获取即初始化）的技术将普通的指针封装为一个**栈对象**。当栈对象的**生存周期**结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。这使得**智能指针实质是一个对象**，行为表现的却像一个指针。

### 1. unique_ptr

1. 基于排他所有权模式：两个指针不能指向同一个资源
2. 无法进行左值unique_ptr复制构造，也无法进行左值复制赋值操作，但允许临时右值赋值构造和赋值
3. 保证指向某个对象的指针，当它本身离开作用域时会自动释放它指向的对象。
4. 在容器中保证指针是安全的无法进行左值复制赋值操作，但允许临时右值赋值构造和赋值

**无法进行左值复制赋值操作，但允许临时右值赋值构造和赋值:**

```cpp
unique_ptr<string> p1(new string("I'm Li Ming!"));
unique_ptr<string> p2(new string("I'm age 22."));
	
cout << "p1：" << p1.get() << endl;
cout << "p2：" << p2.get() << endl;

p1 = p2;					// 禁止左值赋值
unique_ptr<string> p3(p2);	// 禁止左值赋值构造

unique_ptr<string> p3(std::move(p1));
p1 = std::move(p2);	// 使用move把左值转成右值就可以赋值了，效果和auto_ptr赋值一样

cout << "p1 = p2 赋值后：" << endl;
cout << "p1：" << p1.get() << endl;
cout << "p2：" << p2.get() << endl;
```

**在 STL 容器中使用unique_ptr，不允许直接赋值:**

```cpp
vector<unique_ptr<string>> vec;
unique_ptr<string> p3(new string("I'm P3"));
unique_ptr<string> p4(new string("I'm P4"));

vec.push_back(std::move(p3));
vec.push_back(std::move(p4));

cout << "vec.at(0)：" << *vec.at(0) << endl;
cout << "vec[1]：" << *vec[1] << endl;

vec[0] = vec[1];	/* 不允许直接赋值 */
vec[0] = std::move(vec[1]);		// 需要使用move修饰，使得程序员知道后果

cout << "vec.at(0)：" << *vec.at(0) << endl;
cout << "vec[1]：" << *vec[1] << endl;

```



### 2. shared_ptr

C++智能指针shared_ptr是一种可以自动管理内存的智能指针，它是C++11新增的特性之一。与传统指针不同，shared_ptr可以自动释放所管理的动态分配对象的内存，并避免了手动释放内存的繁琐操作，从而减少了内存泄漏和野指针的出现。
shared_ptr是一个模板类，通过引用计数器实现多个智能指针共享对一个对象的所有权。每次复制一个shared_ptr对象时，该对象的引用计数器会增加1，当一个shared_ptr对象被销毁时，引用计数器减1，如果引用计数器变为0，则释放所管理的对象的内存。

### 3. weak_ptr
std::weak_ptr 是一种智能指针，通常不单独使用，只能和 shared_ptr 类型指针搭配使用，可以视为 shared_ptr 指针的一种辅助工具。

weak_ptr可以从一个shared_ptr或者另一个weak_ptr对象构造，获得资源的观测权。但weak_ptr没有共享资源，它的构造不会引起指针引用计数的增加。使用weak_ptr的成员函数use_count()可以观测资源的引用计数，另一个成员函数expired()的功能等价于use_count()==0，但更快。表示被观测的资源(也就是shared_ptr的管理的资源)已经不复存在。

## 6. static关键字

### 6.1.面向过程设计中的static

#### 6.1.1 静态全局变量

在全局变量前，加上关键字static，该变量就被定义成为一个静态全局变量。全局变量和静态全局变量都存放于程序的全局数据区域，它们的生存周期都是程序的整个运行期。这两者的区别在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效。

定义静态全局变量的好处：

- 由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。

#### 6.1.2 静态局部变量

在局部变量前，加上关键字static，该变量就被定义成为一个静态局部变量。通常，在函数体内定义了一个变量，每当程序运行到该语句时都会给该局部变量分配栈内存。但随着程序退出函数体，系统就会收回栈内存，局部变量也相应失效。但有时候我们需要在两次调用之间对变量的值进行保存。通常的想法是定义一个全局变量来实现。但这样一来，变量已经不再属于函数本身了，不再仅受函数的控制，给程序的维护带来不便。
静态局部变量正好可以解决这个问题。静态局部变量保存在全局数据区，而不是保存在栈中，每次的值保持到下一次调用，直到下次赋新值。

静态局部变量有以下特点：
- 该变量在全局数据区分配内存；
- 静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；
- 静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；
- 它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束；

#### 6.1.3 静态函数

在函数的返回类型前加上static关键字,函数即被定义为静态函数。静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。

定义静态函数的好处：
• 静态函数不能被其它文件所用；
• 其它文件中可以定义相同名字的函数，不会发生冲突；

### 6.2 面向对象的static关键字

### 6.2.1 静态数据成员

在类内数据成员的声明前加上关键字static，该数据成员就是类内的静态数据成员。

```cpp
    class MyClass
    {
    public:
        MyClass(int a, int b, int c);
        void fun();
    private:
        int a,b,c;
        static int sum;//声明静态数据成员
    };
     
     int MyClass::sum = 0;
```



静态数据成员有以下特点：

- 对于非静态数据成员，每个类对象都有自己的拷贝。而静态数据成员被当作是类的成员。无论这个类的对象被定义了多少个，静态数据成员在程序中也只有一份拷贝，由该类型的所有对象共享访问。

- 静态数据成员存储在全局数据区。静态数据成员定义时要分配空间，所以不能在类声明中定义。

- 因为静态数据成员在全局数据区分配内存，属于本类的所有对象共享，所以，它不属于特定的类对象，在没有产生类对象时其作用域就可见，即在没有产生类的实例时，我们就可以操作它；

- 静态数据成员初始化与一般数据成员初始化不同。静态数据成员初始化的格式为：＜数据类型＞＜类名＞::＜静态数据成员名＞=＜值＞

- 类的静态数据成员有两种访问形式：＜类对象名＞.＜静态数据成员名＞ 或 ＜类类型名＞::＜静态数据成员名＞

优点：

- 对该类的多个对象来说，静态数据成员只分配一次内存，供所有对象共用，更节省空间。
- 静态数据成员没有进入程序的全局名字空间，因此不存在与程序中其它全局名字冲突的可能性；
- 可以实现信息隐藏。静态数据成员可以是private成员，而全局变量不能

### 6.2.2 静态成员函数

静态成员函数与静态数据成员一样，都是类的内部实现，属于类定义的一部分。它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，它只能调用其余的静态成员函数。

```cpp
#include <iostream>
using namespace std;
class Myclass {
public:
    Myclass(int a, int b, int c);
    static void GetSum();
// 声明静态成员函数 
private :
    int a, b, c;
    static int Sum; //声明静态数据成员
};
int Myclass::Sum = 0; //定义并初始化静态数据成员
Myclass::Myclass(int a, int b, int c) {
	this->a = a;
	this->b = b;
	this->c = c;
	Sum += a + b + c; //非静态成员函数可以访问静态数据成员
}
void Myclass::GetSum() //静态成员函数的实现
{
	// cout<<a<<endl; //错误代码，a是非静态数据成员
	cout << "Sum=" << Sum << endl;
}
int main() {
	Myclass M(1, 2, 3);
	M.GetSum();//Sum=6
	Myclass N(4, 5, 6);
	N.GetSum();//Sum=21
	Myclass::GetSum();//Sum=21
}
```

关于静态成员函数，可以总结为以下几点：
- 出现在类体外的函数定义不能指定关键字static；
- 静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数；
- 非静态成员函数可以任意地访问静态成员函数和静态数据成员；
- 静态成员函数不能访问非静态成员函数和非静态数据成员；
- 由于没有this指针的额外开销，因此静态成员函数与类的全局函数相比速度上会有少许的增长；
- 调用静态成员函数，可以用成员访问操作符(.)和(->)为一个类的对象或指向类对象的指针调用静态成员函数，也可以直接使用如下格式：
＜类名＞::＜静态成员函数名＞（＜参数表＞）调用类的静态成员函数。

## 7. STL

### 7.1顺序容器中的at()和[]

如果stl非空，那么at和下标索引没有区别。如果v为空，调用at会抛出异常，而operator[]索引的行为未定义。c++标准不要求operator[]进行下标越界检查，原因是为了效率，下标越界检查会增加程序的性能开销。

```cpp
int main() {
    vector<int> vec;
    cout<<vec[0];//Segmentation fault
    cout<<vec.at(0);
    /*terminate called after throwing an instance of 'std::out_of_range'
  what():  vector::_M_range_check: __n (which is 0) >= this->size() (which is 0)
Aborted*/
}
int main() {
    vector<int> vec = {1};
    cout<<vec[1];//打印出0
    cout<<vec.at(1);
    /*terminate called after throwing an instance of 'std::out_of_range'
  what():  vector::_M_range_check: __n (which is 1) >= this->size() (which is 1)
Aborted*/
}
```

## 8.左值和右值

## 9.仿函数

## 