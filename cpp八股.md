## 1.  什么是回调函数？

回调函数可以被简单地理解为：A函数作为参数传递给B函数，然后B函数在执行的某一时刻调用A函数。这里的A函数就是回调函数。

## 2.  C++的多态？

**多态的概念：**通俗来讲，多态就是多种形态，具体来讲，就是去完成某个行为，当不同的对象去完成时会产生不同的状态。当基类指针指向子类对象时候，虚函数能实现运行时多态（多态指：同一个接口的不同实现方式）

**多态的分类：** 多态可以分为**编译时的多态**和**运行时的多态**。前者主要是指 **函数的重载**（包括运算符的重载）、对重载函数的调用，在编译时就能根据实参确定应该调用哪个函数，因此叫编译时的多态；而后者则和继承、虚函数等概念有关。

**多态的构成条件: **
1. 必须通过基类的指针或者引用调用虚函数。
2. 被调用的函数必须是虚函数，且派生类必须对基类的虚函数进行重写。
3. 必须存在继承关系

## 3.  C++之函数重载和函数重写
**函数重载：**重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。（在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。不能仅通过返回类型的不同来重载函数。）
**函数重载好处：**函数重载通常用来命名一组功能相似的函数，这样做减少了函数名的数量，避免了名字空间的污染，对于程序的可读性有很大的好处。
**函数重载特征是：**
 （1）相同的范围（在同一个作用域中）；
 （2）函数名字相同；
 （3）参数不同；
 （4）返回值可以不同；

**函数重写（也称为覆盖 override）：**函数重写是指子类重新定义基类的虚函数。

**特征是：**
 （1）不在同一个作用域（分别位于派生类与基类）；
 （2）函数名字相同；
 （3）参数相同；
 （4）基类函数必须有 virtual 关键字，不能有 static 。
 （5）返回值相同，否则报错；
 （6）重写函数的访问修饰符可以不同；

## 4.  虚函数
**虚函数：**即被virtual修饰的类成员函数称为虚函数。
一旦定义了虚函数，该基类的派生类中同名函数也自动成为了虚函数。也就是说在派生类中有一个和基类同名的函数，只要基类加了virtual修饰，派生类不加virtual修饰也是虚函数。
虚函数只能是类中的一个成员函数，不能是静态成员或普通函数。

**虚函数的重写（覆盖）：**派生类中有一个跟基类完全相同的虚函数(即派生类虚函数与基类虚函数的返回值类型、函数名字、参数列表完全相同)，称子类的虚函数重写了基类的虚函数。  

**虚析构函数：**虚析构函数的作用是为了避免内存泄露，而且是当子类中会有指针 成员变量 时才会使用得到的。也就说虚析构函数使得在删除**指向子类对象的基类指针**时可以调用子类的析构函数达到释放子类中堆内存的目的，而防止内存泄露的。

当父类的析构函数不声明成虚析构函数的时候，当子类继承父类，父类的指针指向子类时，delete掉父类的指针，只调动父类的析构函数，而不调动子类的析构函数。

当父类的析构函数声明成虚析构函数的时候，当子类继承父类，父类的指针指向子类时，delete掉父类的指针，先调动子类的析构函数，再调动父类的析构函数。

**纯虚函数：**基类中不对虚函数给出有意义的实现，它只是在派生类中有具体的意义。这时基类中的虚函数只是一个入口，具体的目的地由不同的派生类中的对象决定。这个虚函数称为纯虚函数。

1、在定义纯虚函数时，不能定义虚函数的实现部分。
2、把函数名赋值为0，本质上是将指向函数体的指针值赋为初值0。与定义空函数不一样，空函数的函数体为空，即调用该函数时，不执行任何动作。没有在派生类重新定义这种虚函数之前，是不能调用这种纯虚函数的。
3、把至少包含一个纯虚函数的类，称为**抽象类**。这种类**只能作为派生类的基类**，不能用来创建对象。
其理由是明显的：因为虚函数没有实现部分，所以不能产生对象。但 可以定义指向抽象类的指针，即指向这种基类的指针。当用这种基类指针指向其派生类的对象时，必须在派生类中重载纯虚函数，否则会 产生程序的运行错误。
4、在以抽象类作为基类的派生类中必须有纯虚函数的实现部分，即必须有重写纯虚函数的函数体。否则，这样的派生类也是不能产生对象的。 综上所述，可把纯虚函数归结为：**抽象类的唯一用途是为派生类提供基类，纯虚函数的作用是作为派生类中的成员函数的基础，并实现动态多态性**。

**抽象类：**C++接口时通过抽象类实现的,设计抽象类的目的,是为了给其他类提供一个可以继承的适当的基类.抽象类本类不能被用于实例化对象,只能作为接口使用。在C++中,我们把**只能用于被继承而不能直接创建对象的类**称之为**抽象类**,这种基类不能直接生成对象,而只有被继承后,并重写其虚函数后,才能使用。当抽象类的派生类实现了继承而来的纯虚函数后,才能实例化对象。

## 4.  虚函数表

**什么是虚函数表：**

- 虚函数表是一个指针数组，其元素是虚函数的指针，每个元素对应一个虚函数的函数指针。每一个有虚函数的类（或者从有虚函数的类继承而来的类）都有一个相关联的虚函数表。需要指出的是，普通的函数即非虚函数，其调用并不需要经过虚表，所以虚表的元素并不包括普通函数的函数指针。
- 每个有虚函数的对象都包含一个指向其类的虚函数表的指针。这个指针通常被称为 vptr。
- 当调用一个对象的虚函数时，编译器使用对象的 vptr 来定位类的虚函数表。接着，从虚函数表中找到相应的虚函数指针并调用该函数。这个过程是在运行时进行的，因此可以实现多态行为。
- 虚表内的条目，即虚函数指针的赋值发生在编译器的编译阶段，也就是说在代码的编译阶段，虚表就可以构造出来了。
- 当一个类继承自另一个有虚函数的类，并且没有重写任何虚函数，该类的对象将使用父类的虚函数表。
- 当派生类重写了基类的虚函数，派生类的虚函数表中该函数的入口会被更新为指向派生类版本的函数。
- 如果派生类添加了新的虚函数，它们会被添加到虚函数表的末尾。
- 虚函数表是编译器生成的，程序运行时被载入内存。一个类的虚函数表中列出了该类的全部虚函数地址。


