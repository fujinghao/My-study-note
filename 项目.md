# 数据库

## 项目简介
这部分工作主要是负责opengauss数据库在绿盟自研操作系统上的移植工作。
（因为我们公司是一个安全公司的，产品都是卖给一些运营商、银行这些国企。所以就有信创方面的要求。）
移植的方案最开始是采用docker容器的方式部署。但是，由于我们是设备是嵌入式设备，资源比较紧张。
为了减少资源占用，产品那边的话就希望不要使用docker容器而是直接在我们的系统上运行。

## 项目难点
1. 最开始在安装部署的过程中会有各种各样的报错，所以最开始我们采用docker容器的方式进行部署。容器采用官方提供的dockefile进行构建，容器最开始呢是运行在一个ubuntu虚拟机里面的（因为当时我刚去，对公司的系统还不太熟悉）。确保在ubuntu里面数据库可以正常使用后，就准备移植到公司的系统上去，在公司系统上运行时就遇到一个报错，就是有个文件创建不了，最开始因为是权限的问题，结果改了权限还是不行，然后用ldd命令查看库依赖，发现相关库也是有的。最后就是提供报错信息在opengauss的源码中定位，发现源码中给open函数设置了直接io，当时我们数据库路径下的文件系统是不支持直接io权限的，所以最后就把用docker -v参数将容器中数据库的路径挂载到了支持直接io权限的文件系统上，这样在我们的系统上就可以以容器的方式可以正常运行数据库了。最后尝试不采用容器的方式，直接在公司系统上安装部署数据库，发现也是可以正常运行的。这样下x86上的部署就做完了。
2. 然后arm上主要是两个问题，第一个是我们在运行的时候发现有cpu指令集不支持的问题，然后通过在网络是查找相关信息发现openGauss对鲲鹏处理器等armv8.1或者更高的平台上，有指令集优化，会打开ARM_LSE。我的编译服务器刚好就是华为的泰山处理器，但是目的设备是飞腾的, 就不支持。于是就在编译脚本去掉相关优化。第二个问题是我们arm环境下系统的glibc版本过低，导致数据库只能以docke容器的方式运行。但是，做为嵌入式设备，为了减少资源占用，就希望不要以docker的方式，而是直接在系统上运行。所以最后就采用了chroot的方式，改变当前进程的根路径。（chroot运行还有一点需要注意，从docker中导出的文件系统是不包含系统运行时数据的，如/proc、/sys等目录都是空的，需要挂载宿主机目录，否则会报错）
# 自身安全项目
## 项目简介
本项目是一个自身安全安全检测系统，这个系统分为多个模块、我主要负责了文件检测模块的设计与实现。该模块利用linux系统的inotify机制，实现了对白名单中文件的监控，整个系统支持监控 20w 级别文件数量并且运行时内存小于 50MB ，并且当文件发生创建、删除、修改等事件时，会进行备份并输出告警日志。
## 程序工作流程
1. 解析命令行参数，支持的参数如下：
    - `-c` 配置文件路径，必须项
    - `-D` 是否以守护进程运行
    - `-h` 帮助信息
    - `-d` 是否打印调试信息（输出保存在log文件中）
2. 读取xml配置文件，解析配置文件保存到config结构体中，支持的配置项如下：
    - 文件白名单路径
    - 文件排除白名单路径
    - 端口白名单路径
    - 调试日志和告警日志路径
    - 文件备份路径
    - 需要调用的检测模块
3. 创建相关目录并初始化每个检测模块（每个检测模块提供了init， detect和quit三个函数接口，通过dlopen方式加载动态库，通过dlsym 函数从动态加载的共享库中查找符号，并将这些符号转换为函数指针，赋值给 modules[i] 结构体中的相应成员）。
4. 文件检测模块的初始化步骤包括：
    - 创建前缀树的根节点
    - 创建文件的备份路径
    - 初始化三个合并数组（创建、修改和权限更改）
    - 调用inotify_init()创建inotify实例（非阻塞模式）
    - 加载文件排除白名单
    - 加载文件白名单
    - 调用inotify_add_watch添加文件和路径到监控，每次添加监控inotify_add_watch返回一个文件描述符wd。
    - 将路径插入到前缀树中
    - 将wd和前缀树节点插入到哈希表
5. 文件检测的步骤包括:
    - 每个线程循环调用detect函数
    - 读取inotify实例中的内容到缓冲区
    - 依次处理缓冲区中的每一个inotify_event（包含mask，name， wd）
    - 通过mask判断事件类型是创建、删除还是修改
    - 通过wd找到哈希表中对应的前缀树节点
    - 通过前缀树节点找到文件的路径
    - 通过合并数组判断是否是重复发生的事件（遍历数组，对比wd是否相等以及时间差是否小于60s， 小于60s则直接返回，否则替换为当前事件）
    - 执行备份和输出告警日志
## 项目难点
1. 20w 级别文件数量并且运行时内存小于 50MB。这里我采用了前缀树的方式，将文件路径存储在前缀树中，这样可以快速查找文件路径，同时也可以减少内存的使用。并且在前缀树的子节点分配方式上我采用了动态分配的方式，这样可以减少内存的浪费（如果是固定大小分配的话运行内存会达到接近1个G）。
2. 内存泄漏问题。一般情况下我们检测内存泄漏的方式有两种，一种是手动检查，一种是使用第三方工具检测。
- 手动检查代码的话比较耗费精力，并且在一些没有显式的分配动态态内存的地方很容易遗漏掉（比如说我在项目里读取文件白名单里面用到了c语言里的一个getline函数`ssize_t getline(char **lineptr, size_t *n, FILE *stream);` 它的第一个参数是这是一个指向指针的指针，用于存储读取到的行的内容。如果传入的`lineptr`为NULL，函数会自动分配内存来存储读取到的行, 因为它是可以由函数自动分配的所以我们手动检查内存是否释放掉的话就很容易遗漏掉）。
- 因此这里我采用了valgrind工具检测内存泄漏，通过valgrind --tool=memcheck --leak-check=full --show-leak-kinds=all --track-origins=yes ./main -c config.xml命令检测内存泄漏，发现了一些内存泄漏问题，例如之前提到的getline函数，我在读取文件白名单的结束时候没有释放掉内存，还有就是在添加监控的时候会创建一些结构体，这些结构体后续没有释放掉。
3. 整个程序需要确保与我们的内部操作系统适配的，所以说就会遇到一些库依赖的问题，
比如说我们整个项目会有一些python文件，这些python文件会调用一些第三方库，
这些库在我们的操作系统上没有安装，并且我们项目要求的是要支持兼容python 2.7 和python 3.6两个版本。这里我是去官网上下载了对应的库的源码，然后用平台的编译机编译了x86和arm两个版本的库，
然后在上库的时候将这些库放到对应的路径下，来确保我们的项目能够正常运行。

valgrind除了内存泄漏检测外，还有一些其他的功能：
（1）Memcheck。这是valgrind应用最广泛的工具，一个重量级的内存检查器，能够发现开发中绝大多数内存错误使用情况，比如：使用未初始化的内存，使用已经释放了的内存，内存访问越界等。这也是本文将重点介绍的部分。
（2）Callgrind。它主要用来检查程序中函数调用过程中出现的问题。
（3）Cachegrind。它主要用来检查程序中缓存使用出现的问题。
（4）Helgrind。它主要用来检查多线程程序中出现的竞争问题。
（5）Massif。它主要用来检查程序中堆栈使用中出现的问题。
（6）Extension。可以利用core提供的功能，自己编写特定的内存调试工具

# 皮肤病分割系统
## 项目简介
背景：皮肤癌是一种常见的恶性肿瘤，早期诊断对于患者的治疗和康复至关重要。皮肤镜是一种无创的检测手段，通过放大皮肤表面的图像，可以观察到皮肤表面的细微结构，从而帮助医生诊断皮肤癌。
该系统负责采集临床成像系统的成像结果，通过远端服务器对皮肤镜图像进行预处理与分割分析，实现对皮肤癌的辅助检测，并将定性与定量分析结果对接临床环境。
临床端将采集的皮肤镜图像上传到服务器，服务器对图像进行解析处理，处理完之后将远程分析结果返回给临床端。
图像的上传是通过浏览器发送POST请求，服务器接收到请求后，解析请求报文，提取出请求的图像数据，然后调用TensorRT接口对图像数据进行处理，处理完之后将预测结果返回给临床端。
服务器框架：使用C++编写，采用线程池 + epoll IO多路复用的方式处理客户端请求。
TensorRT使用流程：将.path转换为onnx格式，然后将onnx格式的模型转换为trt格式，最后使用TensorRT对图像数据进行处理。
创建推理引擎，创建TensorRT执行上下文对象，将图像数据输入到引擎中，执行推理，获取输出结果。

# hr面
## 性格
总的来说我是一个比较细心稳重的人，考虑问题比较周全，对待工作认真负责，有责任心，有团队合作精神，能够快速适应新环境。
## 未来规划
未来的话我主要还是往技术方向发展，就是从普通工程师到高级工程师，然后再到架构师这样一个过程。
架构师需要具备哪些能力？
1. 扎实的技术功底，对技术有很深的理解，能够独立解决技术难题。并且能根据业务需求选择合适的技术方案。
2. 有很强的架构设计能力，能够设计出高可用、高性能、高扩展性的系统。
3. 有很强的沟通能力，能够和产品、运营、测试等部门有效沟通，能够将技术方案清晰的传达给其他人。
## 优点
1. 对待工作认真负责，有责任心。能够在规定时间内完成工作，并且也会主动承担支持其他同事的工作上遇到的困难。
2. 有团队合作精神，能够和团队成员有效沟通，共同完成团队目标。
3. 有较强的抗压能力，面对困难能够保持乐观，不退缩，能够快速调整心态，找到解决问题的方法。
## 缺点
1. 做决定的时候有时候会犹豫不决，需要多方考虑，导致决策时间较长，错过一些机会。
2. 有点路痴，出门的时候经常会走错路，需要多次确认才能确定方向。
## 对通用软件开发的理解
我觉得通用软件开发是一个很广泛的概念，它包括了很多方面，比如说前端开发、后端开发、移动端开发或者是一些基础设施平台的搭建。
## 如何和团队成员沟通
1. 明确目标和期望，清晰的表达自己的想法，让团队成员明白自己的意图。
2. 善于倾听，尊重团队成员的意见，不要一味的强调自己的观点。
3. 每周五定期开会，及时解决问题，不要让问题积压。并计划好下一周的工作。