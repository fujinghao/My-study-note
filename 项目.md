## 项目简介
本项目是一个系统自身安全安全检测系统，我主要负责了文件检测模块的设计与实现。该模块利用linux系统的inotify机制，实现了对白名单中文件的监控，整个系统支持监控 20w 级别文件数量并且运行时内存小于 50MB ，并且当文件发生创建、删除、修改等事件时，会进行备份并输出告警日志。
## 程序工作流程
1. 解析命令行参数，支持的参数如下：
    - `-c` 配置文件路径，必须项
    - `-D` 是否以守护进程运行
    - `-h` 帮助信息
    - `-d` 是否打印调试信息（输出保存在log文件中）
2. 读取xml配置文件，解析配置文件保存到config结构体中，支持的配置项如下：
    - 文件白名单路径
    - 文件排除白名单路径
    - 端口白名单路径
    - 调试日志和告警日志路径
    - 文件备份路径
    - 需要调用的检测模块
3. 创建相关目录并初始化每个检测模块（每个检测模块提供了init， detect和quit三个函数接口，通过dlopen方式加载动态库，通过dlsym 函数从动态加载的共享库中查找符号，并将这些符号转换为函数指针，赋值给 modules[i] 结构体中的相应成员）。
4. 文件检测模块的初始化步骤包括：
    - 创建前缀树的根节点
    - 创建文件的备份路径
    - 初始化三个合并数组（创建、修改和权限更改）
    - 调用inotify_init()创建inotify实例（非阻塞模式）
    - 加载文件排除白名单
    - 加载文件白名单
    - 调用inotify_add_watch添加文件和路径到监控，每次添加监控inotify_add_watch返回一个文件描述符wd。
    - 将路径插入到前缀树中
    - 将wd和前缀树节点插入到哈希表
5. 文件检测的步骤包括:
    - 每个线程循环调用detect函数
    - 读取inotify实例中的内容到缓冲区
    - 依次处理缓冲区中的每一个inotify_event（包含mask，name， wd）
    - 通过mask判断事件类型是创建、删除还是修改
    - 通过wd找到哈希表中对应的前缀树节点
    - 通过前缀树节点找到文件的路径
    - 通过合并数组判断是否是重复发生的事件（遍历数组，对比wd是否相等以及时间差是否小于60s， 小于60s则直接返回，否则替换为当前事件）
    - 执行备份和输出告警日志
## 项目难点
1. 20w 级别文件数量并且运行时内存小于 50MB。这里我采用了前缀树的方式，将文件路径存储在前缀树中，这样可以快速查找文件路径，同时也可以减少内存的使用。并且在前缀树的子节点分配方式上我采用了动态分配的方式，这样可以减少内存的浪费（如果是固定大小分配的话运行内存会达到接近1个G）。
2. 内存泄漏问题。一般情况下我们检测内存泄漏的方式有两种，一种是手动检查，一种是使用第三方工具检测。
- 手动检查代码的话比较耗费精力，并且在一些没有显式的分配动态态内存的地方很容易遗漏掉（比如说我在项目里读取文件白名单里面用到了c语言里的一个getline函数`ssize_t getline(char **lineptr, size_t *n, FILE *stream);` 它的第一个参数是这是一个指向指针的指针，用于存储读取到的行的内容。如果传入的`lineptr`为NULL，函数会自动分配内存来存储读取到的行, 因为它是可以由函数自动分配的所以我们手动检查内存是否释放掉的话就很容易遗漏掉）。
- 因此这里我采用了valgrind工具检测内存泄漏，通过valgrind --tool=memcheck --leak-check=full --show-leak-kinds=all --track-origins=yes ./main -c config.xml命令检测内存泄漏，发现了一些内存泄漏问题，例如之前提到的getline函数，我在读取文件白名单的结束时候没有释放掉内存，还有就是在添加监控的时候会创建一些结构体，这些结构体后续没有释放掉。
3. 整个程序需要确保与我们的内部操作系统适配的，所以说就会遇到一些库依赖的问题，比如说我们整个项目会有一些python文件，这些python文件会调用一些第三方库，这些库在我们的操作系统上没有安装，并且我们项目要求的是要支持兼容python 2.7 和python 3.6两个版本。这里我是去官网上下载了对应的库的源码，然后用平台的编译机编译了x86和arm两个版本的库，然后在上库的时候将这些库放到对应的路径下，来确保我们的项目能够正常运行。

valgrind除了内存泄漏检测外，还有一些其他的功能：
（1）Memcheck。这是valgrind应用最广泛的工具，一个重量级的内存检查器，能够发现开发中绝大多数内存错误使用情况，比如：使用未初始化的内存，使用已经释放了的内存，内存访问越界等。这也是本文将重点介绍的部分。
（2）Callgrind。它主要用来检查程序中函数调用过程中出现的问题。
（3）Cachegrind。它主要用来检查程序中缓存使用出现的问题。
（4）Helgrind。它主要用来检查多线程程序中出现的竞争问题。
（5）Massif。它主要用来检查程序中堆栈使用中出现的问题。
（6）Extension。可以利用core提供的功能，自己编写特定的内存调试工具
