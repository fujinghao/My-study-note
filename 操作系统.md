## 1. 发生死锁的 4 个必要条件
- 第 1 个叫**互斥条件**，它的意思是每个资源每次只能被一个线程（或进程，下同）使用，为什么资源不能同时被多个线程或进程使用呢？这是因为如果每个人都可以拿到想要的资源，那就不需要等待，所以是不可能发生死锁的。

- 第 2 个是**请求与保持条件**，它是指当一个线程试图获取资源，但发生了阻塞，则需对已获得的资源保持不放。如果在请求资源时阻塞了，并且会自动释放手中资源（例如锁）的话，那别人自然就能拿到我刚才释放的资源，也就不会形成死锁。

- 第 3 个是**不剥夺条件**，它是指线程已获得的资源，在未使用完之前，不会被强行剥夺。比如我们在上一课时中介绍的数据库的例子，它就有可能去强行剥夺某一个事务所持有的资源，这样就不会发生死锁了。所以要想发生死锁，必须满足不剥夺条件，也就是说当现在的线程获得了某一个资源后，别人就不能来剥夺这个资源，这才有可能形成死锁。
- 第 4 个是**循环等待条件**，通俗得讲就是多个线程之间必须形成“循环等待”，才有可能形成死锁，比如在两个线程之间，这种“循环等待”就意味着它们互相持有对方所需的资源、互相等待；而在三个或更多线程中，则需要形成环路，例如依次请求下一个线程已持有的资源等。

## 2. 进程、线程和协程
**进程：**是系统资源分配的基本单位，实现了操作系统的**并发**。进程拥有自己**独立的堆和栈**，既**不共享堆**，亦**不共享栈**，进程由操作系统调度；切换过程： 用户态->内核态->用户态 

**线程：**是CPU调度的基本单位，实现了进程内的**并发**执行。线程拥有自己**独立的栈**，**共享堆**（也可以有自己的私有域），**不共享栈**，线程亦由操作系统调度。

切换过程： 用户态->内核态->用户态 

**协程**：协程可以理解为轻量级线程，一个线程可以拥有多个协程，与线程相比，协程不受操作系统调度。**上下文切换发生在用户态：** 切换速度比较快，并且开销比较小。

|          | 进程                                                         | 线程                                               | 协程                                                         |
| -------- | ------------------------------------------------------------ | -------------------------------------------------- | ------------------------------------------------------------ |
| 定义     | 资源分配和拥有的基本单位                                     | 程序执行的基本单位                                 | 用户态的轻量级线程，线程内部调度的基本单位                   |
| 切换情况 | 进程CPU环境(栈、寄存器、页表和文件句柄等)的保存以及新调度的进程CPU环境的设置 | 保存和设置程序计数器、少量寄存器和栈的内容         | 先将寄存器上下文和栈保存，等切换回来的时候再进行恢复         |
| 切换者   | 操作系统                                                     | 操作系统                                           | 用户                                                         |
| 切换过程 | 用户态->内核态->用户态                                       | 用户态->内核态->用户态                             | 用户态(没有陷入内核)                                         |
| 调用栈   | 内核栈                                                       | 内核栈                                             | 用户栈                                                       |
| 拥有资源 | CPU资源、内存资源、文件资源和句柄等                          | 程序计数器、寄存器、栈和状态字                     | 拥有自己的寄存器上下文和栈                                   |
| 并发性   | 不同进程之间切换实现并发，各自占有CPU实现并行                | 一个进程内部的多个线程并发执行                     | 同一时间只能执行一个协程，而其他协程处于休眠状态，适合对任务进行分时处理 |
| 系统开销 | 切换虚拟地址空间，切换内核栈和硬件上下文，CPU高速缓存失效、页表切换，开销很大 | 切换时只需保存和设置少量寄存器内容，因此开销很小   | 直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快 |
| 通信方面 | 进程间通信需要借助操作系统                                   | 线程间可以直接读写进程数据段(如全局变量)来进行通信 | 共享内存、消息队列                                           |



## 3. 并行和并发的区别

**并行：**并行在多台处理器上同时处理多个任务。在同一时间点，任务一定是同时运行。
**并发：**并发在一台处理器上“同时”处理多个任务。在同一时间点，任务并不会同时运行。

## 4. 内存分区

<div align=center><img src=".\fig\32位虚拟内存布局.webp"height="565"/> </div>

- 代码区，存放程序的二进制代码和常量；
- 数据段，包括已初始化的静态常量(静态变量只会被初试化一次)和全局变量；
- BSS 段，包括未初始化的静态变量和全局变量；
- 堆区，包括动态分配的内存，从低地址开始向上增长；
- 文件映射区，包括动态库、共享内存等，从低地址开始向上增长（[跟硬件和内核版本有关 (opens new window)](http://lishiwen4.github.io/linux/linux-process-memory-location)）；
- 栈区，用于实现函数调用。由编译器自动分配释放，存放函数的参数值和局部变量等。栈的大小是固定的，一般是 8 MB。当然系统也提供了参数，以便我们自定义大小；
## 4. malloc 是如何分配内存的？

实际上，malloc() 并不是系统调用，而是 C 库里的函数，用于动态分配内存。malloc 申请内存的时候，会有两种方式向操作系统申请堆内存。
- 方式一：通过 brk() 系统调用从堆分配内存
- 方式二：通过 mmap() 系统调用在文件映射区域分配内存；

方式一实现的方式很简单，就是通过 brk() 函数将「堆顶」指针向高地址移动，获得新的内存空间。

方式二通过 mmap() 系统调用中「私有匿名映射」的方式，在文件映射区分配一块内存，也就是从文件映射区“偷”了一块内存。

malloc() 源码里默认定义了一个阈值：

- 如果用户分配的内存小于 128 KB，则通过 brk() 申请内存；
- 如果用户分配的内存大于 128 KB，则通过 mmap() 申请内存；